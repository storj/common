// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: piecestore2.proto

package pbgrpc

import (
	context "context"

	_ "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"

	. "storj.io/common/pb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PiecestoreClient is the client API for Piecestore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PiecestoreClient interface {
	Upload(ctx context.Context, opts ...grpc.CallOption) (Piecestore_UploadClient, error)
	Download(ctx context.Context, opts ...grpc.CallOption) (Piecestore_DownloadClient, error)
	Delete(ctx context.Context, in *PieceDeleteRequest, opts ...grpc.CallOption) (*PieceDeleteResponse, error)
	// DeletePieces deletes a set of pieces on satellite request
	DeletePieces(ctx context.Context, in *DeletePiecesRequest, opts ...grpc.CallOption) (*DeletePiecesResponse, error)
	Retain(ctx context.Context, in *RetainRequest, opts ...grpc.CallOption) (*RetainResponse, error)
	RestoreTrash(ctx context.Context, in *RestoreTrashRequest, opts ...grpc.CallOption) (*RestoreTrashResponse, error)
}

type piecestoreClient struct {
	cc *grpc.ClientConn
}

func NewPiecestoreClient(cc *grpc.ClientConn) PiecestoreClient {
	return &piecestoreClient{cc}
}

func (c *piecestoreClient) Upload(ctx context.Context, opts ...grpc.CallOption) (Piecestore_UploadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Piecestore_serviceDesc.Streams[0], "/piecestore.Piecestore/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &piecestoreUploadClient{stream}
	return x, nil
}

type Piecestore_UploadClient interface {
	Send(*PieceUploadRequest) error
	CloseAndRecv() (*PieceUploadResponse, error)
	grpc.ClientStream
}

type piecestoreUploadClient struct {
	grpc.ClientStream
}

func (x *piecestoreUploadClient) Send(m *PieceUploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *piecestoreUploadClient) CloseAndRecv() (*PieceUploadResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PieceUploadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *piecestoreClient) Download(ctx context.Context, opts ...grpc.CallOption) (Piecestore_DownloadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Piecestore_serviceDesc.Streams[1], "/piecestore.Piecestore/Download", opts...)
	if err != nil {
		return nil, err
	}
	x := &piecestoreDownloadClient{stream}
	return x, nil
}

type Piecestore_DownloadClient interface {
	Send(*PieceDownloadRequest) error
	Recv() (*PieceDownloadResponse, error)
	grpc.ClientStream
}

type piecestoreDownloadClient struct {
	grpc.ClientStream
}

func (x *piecestoreDownloadClient) Send(m *PieceDownloadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *piecestoreDownloadClient) Recv() (*PieceDownloadResponse, error) {
	m := new(PieceDownloadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Deprecated: Do not use.
func (c *piecestoreClient) Delete(ctx context.Context, in *PieceDeleteRequest, opts ...grpc.CallOption) (*PieceDeleteResponse, error) {
	out := new(PieceDeleteResponse)
	err := c.cc.Invoke(ctx, "/piecestore.Piecestore/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *piecestoreClient) DeletePieces(ctx context.Context, in *DeletePiecesRequest, opts ...grpc.CallOption) (*DeletePiecesResponse, error) {
	out := new(DeletePiecesResponse)
	err := c.cc.Invoke(ctx, "/piecestore.Piecestore/DeletePieces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *piecestoreClient) Retain(ctx context.Context, in *RetainRequest, opts ...grpc.CallOption) (*RetainResponse, error) {
	out := new(RetainResponse)
	err := c.cc.Invoke(ctx, "/piecestore.Piecestore/Retain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *piecestoreClient) RestoreTrash(ctx context.Context, in *RestoreTrashRequest, opts ...grpc.CallOption) (*RestoreTrashResponse, error) {
	out := new(RestoreTrashResponse)
	err := c.cc.Invoke(ctx, "/piecestore.Piecestore/RestoreTrash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PiecestoreServer is the server API for Piecestore service.
type PiecestoreServer interface {
	Upload(Piecestore_UploadServer) error
	Download(Piecestore_DownloadServer) error
	Delete(context.Context, *PieceDeleteRequest) (*PieceDeleteResponse, error)
	// DeletePieces deletes a set of pieces on satellite request
	DeletePieces(context.Context, *DeletePiecesRequest) (*DeletePiecesResponse, error)
	Retain(context.Context, *RetainRequest) (*RetainResponse, error)
	RestoreTrash(context.Context, *RestoreTrashRequest) (*RestoreTrashResponse, error)
}

func RegisterPiecestoreServer(s *grpc.Server, srv PiecestoreServer) {
	s.RegisterService(&_Piecestore_serviceDesc, srv)
}

func _Piecestore_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PiecestoreServer).Upload(&piecestoreUploadServer{stream})
}

type Piecestore_UploadServer interface {
	SendAndClose(*PieceUploadResponse) error
	Recv() (*PieceUploadRequest, error)
	grpc.ServerStream
}

type piecestoreUploadServer struct {
	grpc.ServerStream
}

func (x *piecestoreUploadServer) SendAndClose(m *PieceUploadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *piecestoreUploadServer) Recv() (*PieceUploadRequest, error) {
	m := new(PieceUploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Piecestore_Download_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PiecestoreServer).Download(&piecestoreDownloadServer{stream})
}

type Piecestore_DownloadServer interface {
	Send(*PieceDownloadResponse) error
	Recv() (*PieceDownloadRequest, error)
	grpc.ServerStream
}

type piecestoreDownloadServer struct {
	grpc.ServerStream
}

func (x *piecestoreDownloadServer) Send(m *PieceDownloadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *piecestoreDownloadServer) Recv() (*PieceDownloadRequest, error) {
	m := new(PieceDownloadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Piecestore_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PieceDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PiecestoreServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/piecestore.Piecestore/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PiecestoreServer).Delete(ctx, req.(*PieceDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Piecestore_DeletePieces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePiecesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PiecestoreServer).DeletePieces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/piecestore.Piecestore/DeletePieces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PiecestoreServer).DeletePieces(ctx, req.(*DeletePiecesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Piecestore_Retain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PiecestoreServer).Retain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/piecestore.Piecestore/Retain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PiecestoreServer).Retain(ctx, req.(*RetainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Piecestore_RestoreTrash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreTrashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PiecestoreServer).RestoreTrash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/piecestore.Piecestore/RestoreTrash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PiecestoreServer).RestoreTrash(ctx, req.(*RestoreTrashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Piecestore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "piecestore.Piecestore",
	HandlerType: (*PiecestoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _Piecestore_Delete_Handler,
		},
		{
			MethodName: "DeletePieces",
			Handler:    _Piecestore_DeletePieces_Handler,
		},
		{
			MethodName: "Retain",
			Handler:    _Piecestore_Retain_Handler,
		},
		{
			MethodName: "RestoreTrash",
			Handler:    _Piecestore_RestoreTrash_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _Piecestore_Upload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Download",
			Handler:       _Piecestore_Download_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "piecestore2.proto",
}

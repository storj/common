// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: inspector.proto

package pbgrpc

import (
	context "context"

	_ "github.com/gogo/protobuf/gogoproto"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"

	. "storj.io/common/pb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OverlayInspectorClient is the client API for OverlayInspector service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OverlayInspectorClient interface {
	// CountNodes returns the number of nodes in the cache
	CountNodes(ctx context.Context, in *CountNodesRequest, opts ...grpc.CallOption) (*CountNodesResponse, error)
	// DumpNodes returns all the nodes in the cache
	DumpNodes(ctx context.Context, in *DumpNodesRequest, opts ...grpc.CallOption) (*DumpNodesResponse, error)
}

type overlayInspectorClient struct {
	cc *grpc.ClientConn
}

func NewOverlayInspectorClient(cc *grpc.ClientConn) OverlayInspectorClient {
	return &overlayInspectorClient{cc}
}

func (c *overlayInspectorClient) CountNodes(ctx context.Context, in *CountNodesRequest, opts ...grpc.CallOption) (*CountNodesResponse, error) {
	out := new(CountNodesResponse)
	err := c.cc.Invoke(ctx, "/inspector.OverlayInspector/CountNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlayInspectorClient) DumpNodes(ctx context.Context, in *DumpNodesRequest, opts ...grpc.CallOption) (*DumpNodesResponse, error) {
	out := new(DumpNodesResponse)
	err := c.cc.Invoke(ctx, "/inspector.OverlayInspector/DumpNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OverlayInspectorServer is the server API for OverlayInspector service.
type OverlayInspectorServer interface {
	// CountNodes returns the number of nodes in the cache
	CountNodes(context.Context, *CountNodesRequest) (*CountNodesResponse, error)
	// DumpNodes returns all the nodes in the cache
	DumpNodes(context.Context, *DumpNodesRequest) (*DumpNodesResponse, error)
}

func RegisterOverlayInspectorServer(s *grpc.Server, srv OverlayInspectorServer) {
	s.RegisterService(&_OverlayInspector_serviceDesc, srv)
}

func _OverlayInspector_CountNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlayInspectorServer).CountNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inspector.OverlayInspector/CountNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlayInspectorServer).CountNodes(ctx, req.(*CountNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverlayInspector_DumpNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlayInspectorServer).DumpNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inspector.OverlayInspector/DumpNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlayInspectorServer).DumpNodes(ctx, req.(*DumpNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OverlayInspector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "inspector.OverlayInspector",
	HandlerType: (*OverlayInspectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CountNodes",
			Handler:    _OverlayInspector_CountNodes_Handler,
		},
		{
			MethodName: "DumpNodes",
			Handler:    _OverlayInspector_DumpNodes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "inspector.proto",
}

// PieceStoreInspectorClient is the client API for PieceStoreInspector service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PieceStoreInspectorClient interface {
	// Stats return space and bandwidth stats for a storagenode
	Stats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatSummaryResponse, error)
	// Dashboard returns stats for a specific storagenode
	Dashboard(ctx context.Context, in *DashboardRequest, opts ...grpc.CallOption) (*DashboardResponse, error)
}

type pieceStoreInspectorClient struct {
	cc *grpc.ClientConn
}

func NewPieceStoreInspectorClient(cc *grpc.ClientConn) PieceStoreInspectorClient {
	return &pieceStoreInspectorClient{cc}
}

func (c *pieceStoreInspectorClient) Stats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatSummaryResponse, error) {
	out := new(StatSummaryResponse)
	err := c.cc.Invoke(ctx, "/inspector.PieceStoreInspector/Stats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pieceStoreInspectorClient) Dashboard(ctx context.Context, in *DashboardRequest, opts ...grpc.CallOption) (*DashboardResponse, error) {
	out := new(DashboardResponse)
	err := c.cc.Invoke(ctx, "/inspector.PieceStoreInspector/Dashboard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PieceStoreInspectorServer is the server API for PieceStoreInspector service.
type PieceStoreInspectorServer interface {
	// Stats return space and bandwidth stats for a storagenode
	Stats(context.Context, *StatsRequest) (*StatSummaryResponse, error)
	// Dashboard returns stats for a specific storagenode
	Dashboard(context.Context, *DashboardRequest) (*DashboardResponse, error)
}

func RegisterPieceStoreInspectorServer(s *grpc.Server, srv PieceStoreInspectorServer) {
	s.RegisterService(&_PieceStoreInspector_serviceDesc, srv)
}

func _PieceStoreInspector_Stats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PieceStoreInspectorServer).Stats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inspector.PieceStoreInspector/Stats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PieceStoreInspectorServer).Stats(ctx, req.(*StatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PieceStoreInspector_Dashboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DashboardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PieceStoreInspectorServer).Dashboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inspector.PieceStoreInspector/Dashboard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PieceStoreInspectorServer).Dashboard(ctx, req.(*DashboardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PieceStoreInspector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "inspector.PieceStoreInspector",
	HandlerType: (*PieceStoreInspectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Stats",
			Handler:    _PieceStoreInspector_Stats_Handler,
		},
		{
			MethodName: "Dashboard",
			Handler:    _PieceStoreInspector_Dashboard_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "inspector.proto",
}

// IrreparableInspectorClient is the client API for IrreparableInspector service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IrreparableInspectorClient interface {
	// ListIrreparableSegments returns damaged segments
	ListIrreparableSegments(ctx context.Context, in *ListIrreparableSegmentsRequest, opts ...grpc.CallOption) (*ListIrreparableSegmentsResponse, error)
}

type irreparableInspectorClient struct {
	cc *grpc.ClientConn
}

func NewIrreparableInspectorClient(cc *grpc.ClientConn) IrreparableInspectorClient {
	return &irreparableInspectorClient{cc}
}

func (c *irreparableInspectorClient) ListIrreparableSegments(ctx context.Context, in *ListIrreparableSegmentsRequest, opts ...grpc.CallOption) (*ListIrreparableSegmentsResponse, error) {
	out := new(ListIrreparableSegmentsResponse)
	err := c.cc.Invoke(ctx, "/inspector.IrreparableInspector/ListIrreparableSegments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IrreparableInspectorServer is the server API for IrreparableInspector service.
type IrreparableInspectorServer interface {
	// ListIrreparableSegments returns damaged segments
	ListIrreparableSegments(context.Context, *ListIrreparableSegmentsRequest) (*ListIrreparableSegmentsResponse, error)
}

func RegisterIrreparableInspectorServer(s *grpc.Server, srv IrreparableInspectorServer) {
	s.RegisterService(&_IrreparableInspector_serviceDesc, srv)
}

func _IrreparableInspector_ListIrreparableSegments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListIrreparableSegmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IrreparableInspectorServer).ListIrreparableSegments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inspector.IrreparableInspector/ListIrreparableSegments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IrreparableInspectorServer).ListIrreparableSegments(ctx, req.(*ListIrreparableSegmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _IrreparableInspector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "inspector.IrreparableInspector",
	HandlerType: (*IrreparableInspectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListIrreparableSegments",
			Handler:    _IrreparableInspector_ListIrreparableSegments_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "inspector.proto",
}

// HealthInspectorClient is the client API for HealthInspector service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type HealthInspectorClient interface {
	// ObjectHealth will return stats about the health of an object
	ObjectHealth(ctx context.Context, in *ObjectHealthRequest, opts ...grpc.CallOption) (*ObjectHealthResponse, error)
	// SegmentHealth will return stats about the health of a segment
	SegmentHealth(ctx context.Context, in *SegmentHealthRequest, opts ...grpc.CallOption) (*SegmentHealthResponse, error)
}

type healthInspectorClient struct {
	cc *grpc.ClientConn
}

func NewHealthInspectorClient(cc *grpc.ClientConn) HealthInspectorClient {
	return &healthInspectorClient{cc}
}

func (c *healthInspectorClient) ObjectHealth(ctx context.Context, in *ObjectHealthRequest, opts ...grpc.CallOption) (*ObjectHealthResponse, error) {
	out := new(ObjectHealthResponse)
	err := c.cc.Invoke(ctx, "/inspector.HealthInspector/ObjectHealth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthInspectorClient) SegmentHealth(ctx context.Context, in *SegmentHealthRequest, opts ...grpc.CallOption) (*SegmentHealthResponse, error) {
	out := new(SegmentHealthResponse)
	err := c.cc.Invoke(ctx, "/inspector.HealthInspector/SegmentHealth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthInspectorServer is the server API for HealthInspector service.
type HealthInspectorServer interface {
	// ObjectHealth will return stats about the health of an object
	ObjectHealth(context.Context, *ObjectHealthRequest) (*ObjectHealthResponse, error)
	// SegmentHealth will return stats about the health of a segment
	SegmentHealth(context.Context, *SegmentHealthRequest) (*SegmentHealthResponse, error)
}

func RegisterHealthInspectorServer(s *grpc.Server, srv HealthInspectorServer) {
	s.RegisterService(&_HealthInspector_serviceDesc, srv)
}

func _HealthInspector_ObjectHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthInspectorServer).ObjectHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inspector.HealthInspector/ObjectHealth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthInspectorServer).ObjectHealth(ctx, req.(*ObjectHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthInspector_SegmentHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SegmentHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthInspectorServer).SegmentHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inspector.HealthInspector/SegmentHealth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthInspectorServer).SegmentHealth(ctx, req.(*SegmentHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _HealthInspector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "inspector.HealthInspector",
	HandlerType: (*HealthInspectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ObjectHealth",
			Handler:    _HealthInspector_ObjectHealth_Handler,
		},
		{
			MethodName: "SegmentHealth",
			Handler:    _HealthInspector_SegmentHealth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "inspector.proto",
}
